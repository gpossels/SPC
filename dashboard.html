<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard SPC - An√°lisis de Procesos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-datalabels/2.2.0/chartjs-plugin-datalabels.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: white;
            min-height: 100vh;
            padding: 20px;
            color: black;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border: 2px solid black;
            border-radius: 8px;
            overflow: hidden;
        }

        .header {
            background: white;
            color: black;
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid black;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.8;
        }

        .main-content {
            padding: 40px;
        }

        .upload-section {
            background: white;
            padding: 40px;
            border: 2px solid black;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            background: #f9f9f9;
        }

        .upload-section.dragover {
            background: #f0f0f0;
            border-style: dashed;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: white;
            color: black;
            padding: 15px 40px;
            border: 2px solid black;
            border-radius: 4px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-btn:hover {
            background: #f0f0f0;
        }

        .upload-info {
            margin-top: 20px;
            color: black;
            font-size: 0.9em;
            opacity: 0.7;
        }

        .chart-section {
            display: none;
            background: white;
            border: 2px solid black;
            border-radius: 8px;
            overflow: hidden;
        }

        .chart-header {
            background: white;
            color: black;
            padding: 20px 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 2px solid black;
        }

        .chart-navigation {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .nav-btn {
            background: white;
            color: black;
            border: 2px solid black;
            border-radius: 4px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 1.2em;
            font-weight: bold;
        }

        .nav-btn:hover {
            background: #f0f0f0;
        }

        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .metric-selector {
            background: white;
            color: black;
            border: 2px solid black;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        .metric-selector:hover {
            background: #f0f0f0;
        }

        .metric-selector:focus {
            outline: none;
            background: #f0f0f0;
        }

        .chart-counter {
            color: black;
            font-size: 0.9em;
            font-weight: bold;
        }

        .lang-toggle {
            background: white;
            color: black;
            border: 2px solid black;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin-top: 15px;
        }

        .lang-toggle:hover {
            background: #f0f0f0;
        }

        .header-back-btn {
            background: white;
            color: black;
            border: 2px solid black;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin-top: 10px;
        }

        .header-back-btn:hover {
            background: #f0f0f0;
        }

        .download-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .download-btn {
            background: white;
            color: black;
            border: 2px solid black;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            min-width: 150px;
        }

        .download-btn:hover {
            background: #f0f0f0;
        }

        .download-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .chart-container {
            position: relative;
            height: 600px;
            padding: 30px;
            background: white;
        }

        .error-message {
            background: white;
            color: black;
            padding: 15px;
            border: 2px solid black;
            border-radius: 4px;
            margin: 20px 0;
            display: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: black;
            font-weight: bold;
        }

        .loading::after {
            content: "";
            width: 40px;
            height: 40px;
            border: 4px solid #f0f0f0;
            border-top: 4px solid black;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 20px;
            }
            
            .chart-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .chart-container {
                height: 400px;
                padding: 15px;
            }

            .download-buttons {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="mainTitle">Panel PBC</h1>
            <p id="mainSubtitle">Panel de Comportamiento de Procesos</p>
            <p id="authorCredit" style="margin-top: 20px; font-size: 0.9em; color: black;">Dr. Gustavo Possel S. - M√©dico</p>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 15px;">
                <button id="backToIndex" class="lang-toggle btn-green">‚Üê Inicio</button>
                <div id="downloadButtonsContainer" class="download-buttons" style="display: none;">
                    <button id="downloadPDF" class="download-btn">üìÑ Descargar PDF</button>
                    <button id="downloadODP" class="download-btn">üìä Descargar ODP</button>
                </div>
                <button id="langToggle" class="lang-toggle">English</button>
            </div>
            <button id="headerBackBtn" class="header-back-btn btn-red" style="display: none;">‚Üê Cargar Nuevo Archivo</button>
        </div>

        <div class="main-content">
            <div id="uploadSection" class="upload-section">
                <h3>Cargar Archivo de Datos</h3>
                <p>Seleccione un archivo Excel (.xlsx, .xls) o CSV con sus datos de m√©tricas</p>
                <input type="file" id="fileInput" class="file-input" accept=".xlsx,.xls,.csv">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    üìÅ Seleccionar Archivo
                </button>
                <div class="upload-info">
                    <p>El archivo debe contener columnas para: Centro, fechas (A√±o, Mes, etc.) y m√©tricas a analizar</p>
                </div>
            </div>

            <div id="errorMessage" class="error-message"></div>

            <div id="loadingSection" class="loading" style="display: none;">
                Procesando archivo...
            </div>

            <div id="chartSection" class="chart-section">
                <div class="chart-header">
                    <div class="chart-navigation">
                        <button id="prevChart" class="nav-btn">‚Üê</button>
                        <span id="chartCounter" class="chart-counter">1 / 1</span>
                        <button id="nextChart" class="nav-btn">‚Üí</button>
                        <select id="metricSelector" class="metric-selector">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="spcChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let uploadedData = null;
        let currentChartIndex = 0;
        let spcChart = null;
        let processedResults = [];
        let isEnglish = false;

        // Language translations
        const translations = {
            es: {
                title: 'Panel PBC',
                subtitle: 'Panel de Comportamiento de Procesos',
                authorCredit: 'Dr. Gustavo Possel S. - M√©dico',
                uploadTitle: 'Cargar Archivo de Datos',
                uploadDesc: 'Seleccione un archivo Excel (.xlsx, .xls) o CSV con sus datos de m√©tricas',
                uploadBtn: 'üìÅ Seleccionar Archivo',
                uploadInfo: 'El archivo debe contener columnas para: Centro/Institution, fechas (A√±o, Mes, etc.) y m√©tricas a analizar',
                backBtn: '‚Üê Cargar Nuevo Archivo',
                backToIndex: '‚Üê Inicio',
                downloadPDF: 'üìÑ Descargar PDF',
                downloadODP: 'üìä Descargar Presentaci√≥n (ODP)',
                downloadingPDF: 'Generando PDF...',
                downloadingODP: 'Generando ODP...',
                processing: 'Procesando archivo...',
                errorMissingData: 'Datos faltantes o inv√°lidos en los √∫ltimos 24 puntos',
                errorInsufficientData: 'Insuficientes datos v√°lidos (m√≠nimo 8 puntos)',
                errorNoValidMetrics: 'No se encontraron m√©tricas v√°lidas para SPC (se necesitan al menos 8 puntos de datos por m√©trica)',
                errorFileFormat: 'Formato de archivo no soportado. Use .xlsx, .xls o .csv',
                errorProcessing: 'Error al procesar el archivo: ',
                period: 'Per√≠odo',
                value: 'Valor',
                average: 'Promedio (DPA)',
                upperLimit: 'L√≠mite Superior (UCL)',
                lowerLimit: 'L√≠mite Inferior (LCL)',
                signalDetected: 'üö® SE√ëAL DETECTADA',
                points: 'puntos'
            },
            en: {
                title: 'PBC Dashboard',
                subtitle: 'Process Behavior Chart Panel',
                authorCredit: 'Dr. Gustavo Possel S. - MD',
                uploadTitle: 'Load Data File',
                uploadDesc: 'Select an Excel (.xlsx, .xls) or CSV file with your metrics data',
                uploadBtn: 'üìÅ Select File',
                uploadInfo: 'The file must contain columns for: Center, dates (Year, Month, etc.) and metrics to analyze',
                backBtn: '‚Üê Load New File',
                backToIndex: '‚Üê Home',
                downloadPDF: 'üìÑ Download PDF',
                downloadODP: 'üìä Download Slides (ODP)',
                downloadingPDF: 'Generating PDF...',
                downloadingODP: 'Generating ODP...',
                processing: 'Processing file...',
                errorMissingData: 'Missing or invalid data in the last 24 points',
                errorInsufficientData: 'Insufficient valid data (minimum 8 points)',
                errorNoValidMetrics: 'No valid metrics found for SPC (at least 8 data points required per metric)',
                errorFileFormat: 'Unsupported file format. Use .xlsx, .xls or .csv',
                errorProcessing: 'Error processing file: ',
                period: 'Period',
                value: 'Value',
                average: 'Average (DPA)',
                upperLimit: 'Upper Limit (UCL)',
                lowerLimit: 'Lower Limit (LCL)',
                signalDetected: 'üö® SIGNAL DETECTED',
                points: 'points'
            }
        };
// Month abbreviations for different languages
const monthAbbreviations = {
    es: ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'],
    en: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
};

// Function to get month abbreviations based on current language
function getMonthAbbreviations() {
    return isEnglish ? monthAbbreviations.en : monthAbbreviations.es;
}

// Replace the existing month handling section in processAllMetrics function
// Find this line in processAllMetrics():
// const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];

// Replace it with:
const monthNames = getMonthAbbreviations();

// Additionally, update the formatExcelDate function to use language-appropriate formatting
function formatExcelDate(dateValue) {
    if (typeof dateValue === 'number' && dateValue > 1000) {
        const baseDate = new Date(1899, 11, 30);
        const msPerDay = 24 * 60 * 60 * 1000;
        const jsDate = new Date(baseDate.getTime() + (dateValue * msPerDay));
        
        // Use language-appropriate month abbreviations
        const monthNames = getMonthAbbreviations();
        const month = jsDate.getMonth();
        const year = jsDate.getFullYear();
        
        return `${monthNames[month]} ${year}`;
    }
    return dateValue.toString();
}
        function getCurrentLang() {
            return isEnglish ? translations.en : translations.es;
        }

        function updateLanguage() {
            const lang = getCurrentLang();
            
            document.getElementById('mainTitle').textContent = lang.title;
            document.getElementById('mainSubtitle').textContent = lang.subtitle;
            document.getElementById('authorCredit').textContent = lang.authorCredit;
            document.getElementById('langToggle').textContent = isEnglish ? 'Espa√±ol' : 'English';
            document.getElementById('backToIndex').textContent = lang.backToIndex;
            
            // Update upload section if visible
            const uploadSection = document.getElementById('uploadSection');
            if (uploadSection.style.display !== 'none') {
                uploadSection.querySelector('h3').textContent = lang.uploadTitle;
                uploadSection.querySelector('p').textContent = lang.uploadDesc;
                uploadSection.querySelector('button').innerHTML = lang.uploadBtn;
                uploadSection.querySelector('.upload-info p').textContent = lang.uploadInfo;
            }
            
            // Update chart section if visible
            const chartSection = document.getElementById('chartSection');
            if (chartSection.style.display !== 'none') {
                document.getElementById('headerBackBtn').textContent = lang.backBtn;
                document.getElementById('downloadPDF').textContent = lang.downloadPDF;
                document.getElementById('downloadODP').textContent = lang.downloadODP;
                
                // Update current chart if it exists
                if (spcChart) {
                    updateChart();
                }
            }
            
            // Update loading text if visible
            const loadingSection = document.getElementById('loadingSection');
            if (loadingSection.style.display !== 'none') {
                loadingSection.textContent = lang.processing;
            }
        }

        // Number formatting
        function fmt(num) {
            return num.toFixed(2).replace('.', ',');
        }

        // Parse numeric data with various formats
        function parseNumericData(input) {
            let items = input.split(/[\s\t\n]+/).filter(s => s.trim());
            const result = [];
            
            for (const item of items) {
                let normalized = item.trim();
                
                if (normalized.includes(',') && normalized.includes('.')) {
                    const lastCommaPos = normalized.lastIndexOf(',');
                    const lastDotPos = normalized.lastIndexOf('.');
                    
                    if (lastDotPos > lastCommaPos) {
                        normalized = normalized.replace(/,/g, '');
                    } else {
                        normalized = normalized.replace(/\./g, '').replace(',', '.');
                    }
                } else if (normalized.includes(',')) {
                    const commaPos = normalized.indexOf(',');
                    const afterComma = normalized.substring(commaPos + 1);
                    
                    if (afterComma.length <= 3 && !afterComma.includes(',')) {
                        normalized = normalized.replace(',', '.');
                    } else {
                        normalized = normalized.replace(/,/g, '');
                    }
                } else if (normalized.includes('.')) {
                    const dotPos = normalized.indexOf('.');
                    const afterDot = normalized.substring(dotPos + 1);
                    
                    if (afterDot.length > 3 || afterDot.includes('.')) {
                        normalized = normalized.replace(/\./g, '');
                    }
                }
                
                const num = parseFloat(normalized);
                if (!isNaN(num)) {
                    result.push(num);
                }
            }
            
            return result;
        }

        // SPC Calculation
        function calcSPC(data, periods) {
            const results = data.map((dp, i) => ({
                period: i + 1,
                date: periods[i],
                dp: dp,
                dpa: null, mr: null, mra: null,
                lcl: null, ucl: null, mrucl: null,
                rule: null, ruleApplied: null, signal: null
            }));

            // Baseline calculation (first 8 points)
            const dpa = data.slice(0, 8).reduce((a, b) => a + b) / 8;
            const mrs = [];
            for (let i = 1; i < 8; i++) {
                mrs.push(Math.abs(data[i] - data[i-1]));
            }
            const mra = mrs.reduce((a, b) => a + b) / mrs.length;
            
            const factor = 3/1.128;
            const lcl = dpa - (mra * factor);
            const ucl = dpa + (mra * factor);
            const mrucl = mra * 3.27;

            // Apply baseline to first 8 rows
            for (let i = 0; i < 8; i++) {
                results[i].dpa = dpa;
                results[i].mra = mra;
                results[i].lcl = lcl;
                results[i].ucl = ucl;
                results[i].mrucl = mrucl;
                results[i].ruleApplied = 'L√≠nea Base';
                if (i > 0) results[i].mr = Math.abs(data[i] - data[i-1]);
            }

            // Process remaining points with SPC rules
            for (let i = 8; i < data.length; i++) {
                const curr = data[i];
                const prev = data[i-1];
                const mr = Math.abs(curr - prev);
                results[i].mr = mr;
                
                const currentResult = results[i-1];
                const currentDPA = currentResult.dpa;
                const currentMRA = currentResult.mra;
                const currentLCL = currentResult.lcl;
                const currentUCL = currentResult.ucl;
                const currentMRUCL = currentResult.mrucl;
                
                let ruleTriggered = false;

                // Rule 1: DP outside control limits AND MR > MRUCL
                if ((curr > currentUCL || curr < currentLCL) && mr > currentMRUCL) {
                    results[i].signal = 1;
                }

                // Rule 2: All 8 recent DPs above or below current DPA
                if (i >= 7) {
                    const last8 = data.slice(i-7, i+1);
                    const allAboveDPA = last8.every(dp => dp > currentDPA);
                    const allBelowDPA = last8.every(dp => dp < currentDPA);
                    
                    if (allAboveDPA || allBelowDPA) {
                        ruleTriggered = true;
                        
                        const newDPA = last8.reduce((a, b) => a + b) / 8;
                        const newMRs = [];
                        if (i-8 >= 0) {
                            newMRs.push(Math.abs(data[i-7] - data[i-8]));
                        } else {
                            newMRs.push(0);
                        }
                        for (let j = 1; j < 8; j++) {
                            newMRs.push(Math.abs(last8[j] - last8[j-1]));
                        }
                        
                        const newMRA = newMRs.reduce((a, b) => a + b) / newMRs.length;
                        const newLCL = newDPA - (newMRA * factor);
                        const newUCL = newDPA + (newMRA * factor);
                        const newMRUCL = newMRA * 3.27;
                        
                        for (let j = i-7; j <= i; j++) {
                            results[j].dpa = newDPA;
                            results[j].mra = newMRA;
                            results[j].lcl = newLCL;
                            results[j].ucl = newUCL;
                            results[j].mrucl = newMRUCL;
                            results[j].ruleApplied = 'Regla 2';
                        }
                        results[i].rule = 'Regla 2';
                    }
                }

                // Rule 3: At least 3 of last 4 DPs above DUA or below DLA
                if (!ruleTriggered && i >= 3) {
                    const currentDLA = (currentLCL + currentDPA) / 2;
                    const currentDUA = (currentDPA + currentUCL) / 2;
                    const last4 = data.slice(i-3, i+1);
                    const aboveDUA = last4.filter(dp => dp > currentDUA).length;
                    const belowDLA = last4.filter(dp => dp < currentDLA).length;
                    
                    if (aboveDUA >= 3 || belowDLA >= 3) {
                        ruleTriggered = true;
                        
                        const newDPA = last4.reduce((a, b) => a + b) / 4;
                        const newMRs = [];
                        if (i-4 >= 0) {
                            newMRs.push(Math.abs(data[i-3] - data[i-4]));
                        } else {
                            newMRs.push(0);
                        }
                        for (let j = 1; j < 4; j++) {
                            newMRs.push(Math.abs(last4[j] - last4[j-1]));
                        }
                        
                        const newMRA = newMRs.reduce((a, b) => a + b) / newMRs.length;
                        const newLCL = newDPA - (newMRA * factor);
                        const newUCL = newDPA + (newMRA * factor);
                        const newMRUCL = newMRA * 3.27;
                        
                        for (let j = i-3; j <= i; j++) {
                            results[j].dpa = newDPA;
                            results[j].mra = newMRA;
                            results[j].lcl = newLCL;
                            results[j].ucl = newUCL;
                            results[j].mrucl = newMRUCL;
                            results[j].ruleApplied = 'Regla 3';
                        }
                        results[i].rule = 'Regla 3';
                    }
                }

                // If no rules triggered, copy current baseline
                if (!ruleTriggered) {
                    results[i].dpa = currentDPA;
                    results[i].mra = currentMRA;
                    results[i].lcl = currentLCL;
                    results[i].ucl = currentUCL;
                    results[i].mrucl = currentMRUCL;
                    results[i].ruleApplied = currentResult.ruleApplied;
                }
            }

            return results;
        }

        // File processing
        function processExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, {type: 'array'});
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function processCSVFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const csv = e.target.result;
                        const lines = csv.split('\n');
                        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                        const data = [];
                        
                        for (let i = 1; i < lines.length; i++) {
                            if (lines[i].trim()) {
                                const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                                const row = {};
                                headers.forEach((header, index) => {
                                    row[header] = values[index] || '';
                                });
                                data.push(row);
                            }
                        }
                        resolve(data);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.readAsText(file, 'utf-8');
            });
        }

        function analyzeDataStructure(data) {
            if (!data || data.length === 0) {
                throw new Error('No se encontraron datos en el archivo');
            }

            const headers = Object.keys(data[0]);
            console.log('All headers found:', headers);

            // Find institution column
            const institutionColumn = headers.find(h => 
                h.toLowerCase().includes('centro') || 
                h.toLowerCase().includes('center') ||
                h.toLowerCase().includes('instituci√≥n') ||
                h.toLowerCase().includes('institution')
            );

            // Find date columns
            const fechaColumn = headers.find(h => h.toLowerCase().includes('fecha') || h.toLowerCase().includes('date'));
            console.log('Fecha column found:', fechaColumn);

            const dateColumns = {
                year: headers.find(h => h.toLowerCase().includes('a√±o') || h.toLowerCase().includes('year')),
                month: headers.find(h => h.toLowerCase().includes('mes') || h.toLowerCase().includes('month')),
                week: headers.find(h => h.toLowerCase().includes('semana') || h.toLowerCase().includes('week')),
                day: headers.find(h => h.toLowerCase().includes('d√≠a') || h.toLowerCase().includes('day'))
            };
            console.log('Date columns found:', dateColumns);

            // Find metric columns (exclude institution, date columns, and fecha column)
            const excludeColumns = [institutionColumn, fechaColumn, ...Object.values(dateColumns)].filter(Boolean);
            const metricColumns = headers.filter(h => !excludeColumns.includes(h));

            // Analyze each metric column
            const metrics = metricColumns.map(column => {
                const values = data.map(row => row[column]).filter(v => v !== '' && v !== null && v !== undefined);
                const numericValues = parseNumericData(values.join(' '));
                
                return {
                    name: column,
                    column: column,
                    dataPoints: numericValues.length,
                    validForSPC: numericValues.length >= 8
                };
            });

            return {
                institution: institutionColumn,
                institutionName: institutionColumn ? data[0][institutionColumn] : 'Sin identificar',
                dateColumns: dateColumns,
                fechaColumn: fechaColumn,
                metrics: metrics,
                rawData: data
            };
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            setTimeout(() => {
                errorDiv.style.display = 'none';
            }, 5000);
        }

        function showLoading(show) {
            document.getElementById('loadingSection').style.display = show ? 'block' : 'none';
        }

        function formatExcelDate(dateValue) {
            if (typeof dateValue === 'number' && dateValue > 1000) {
                const baseDate = new Date(1899, 11, 30);
                const msPerDay = 24 * 60 * 60 * 1000;
                const jsDate = new Date(baseDate.getTime() + (dateValue * msPerDay));
                return jsDate.toLocaleDateString('es-ES', { 
                    month: 'short', 
                    year: 'numeric'
                });
            }
            return dateValue.toString();
        }

        function processAllMetrics() {
            showLoading(true);
            
            setTimeout(() => {
                try {
                    processedResults = [];
                    
                    console.log('=== PROCESSING ALL METRICS ===');
                    console.log('uploadedData.fechaColumn:', uploadedData.fechaColumn);
                    console.log('uploadedData.dateColumns:', uploadedData.dateColumns);
                    console.log('Sample row 0:', uploadedData.rawData[0]);
                    console.log('Sample row 1:', uploadedData.rawData[1]);
                    
                    uploadedData.metrics.filter(m => m.validForSPC).forEach(metric => {
                        console.log('\n--- Processing metric:', metric.name, '---');
                        
                        const numericValues = [];
                        const periods = [];
                        let hasError = false;
                        let errorMessage = '';
                        
                        // Get all data first
                        uploadedData.rawData.forEach((row, index) => {
                            const value = row[metric.column];
                            if (value !== '' && value !== null && value !== undefined) {
                                const numValue = parseFloat(value.toString().replace(',', '.'));
                                if (!isNaN(numValue)) {
                                    numericValues.push(numValue);
                                    
                                    let period = '';
                                    
                                    // Debug each row thoroughly
                                    if (index < 3) { // Only log first 3 rows to avoid spam
                                        console.log(`Row ${index}:`);
                                        console.log('  fechaColumn exists:', !!uploadedData.fechaColumn);
                                        console.log('  fechaColumn value:', row[uploadedData.fechaColumn]);
                                        console.log('  year column exists:', !!uploadedData.dateColumns.year);
                                        console.log('  year value:', uploadedData.dateColumns.year ? row[uploadedData.dateColumns.year] : 'N/A');
                                        console.log('  month column exists:', !!uploadedData.dateColumns.month);
                                        console.log('  month value:', uploadedData.dateColumns.month ? row[uploadedData.dateColumns.month] : 'N/A');
                                    }
                                    
                                    if (uploadedData.fechaColumn && row[uploadedData.fechaColumn] !== '' && row[uploadedData.fechaColumn] !== null && row[uploadedData.fechaColumn] !== undefined) {
                                        period = formatExcelDate(row[uploadedData.fechaColumn]);
                                        if (index < 3) console.log('  ‚Üí Using fecha column, result:', period);
                                    } else if (uploadedData.dateColumns.year && row[uploadedData.dateColumns.year] !== '' && row[uploadedData.dateColumns.year] !== null && row[uploadedData.dateColumns.year] !== undefined) {
                                        const year = row[uploadedData.dateColumns.year];
                                        if (uploadedData.dateColumns.month && row[uploadedData.dateColumns.month] !== '' && row[uploadedData.dateColumns.month] !== null && row[uploadedData.dateColumns.month] !== undefined) {
                                            const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                                            const month = parseInt(row[uploadedData.dateColumns.month]);
                                            if (month >= 1 && month <= 12) {
                                                period = `${monthNames[month - 1]} ${year}`;
                                            } else {
                                                period = `${year}`;
                                            }
                                            if (index < 3) console.log('  ‚Üí Using year+month, result:', period);
                                        } else {
                                            period = `${year}`;
                                            if (index < 3) console.log('  ‚Üí Using year only, result:', period);
                                        }
                                    } else {
                                        // Try to find any date-like values in the row
                                        let foundDate = false;
                                        for (const [key, value] of Object.entries(row)) {
                                            if (value && typeof value === 'string') {
                                                // Check for date patterns like DD/MM/YYYY, YYYY-MM-DD, etc.
                                                const datePatterns = [
                                                    /^\d{1,2}\/\d{1,2}\/\d{4}$/,
                                                    /^\d{4}-\d{1,2}-\d{1,2}$/,
                                                    /^\d{1,2}-\d{1,2}-\d{4}$/,
                                                    /^\d{4}\/\d{1,2}\/\d{1,2}$/
                                                ];
                                                
                                                if (datePatterns.some(pattern => pattern.test(value.toString()))) {
                                                    period = value.toString();
                                                    foundDate = true;
                                                    if (index < 3) console.log('  ‚Üí Found date pattern in column', key, ':', period);
                                                    break;
                                                }
                                            }
                                            // Check for Excel date numbers
                                            else if (typeof value === 'number' && value > 1000 && value < 100000) {
                                                period = formatExcelDate(value);
                                                foundDate = true;
                                                if (index < 3) console.log('  ‚Üí Found Excel date number in column', key, ':', period);
                                                break;
                                            }
                                        }
                                        
                                        if (!foundDate) {
                                            period = `Per√≠odo ${numericValues.length}`;
                                            if (index < 3) console.log('  ‚Üí Fallback to period number, result:', period);
                                        }
                                    }
                                    periods.push(period);
                                }
                            }
                        });
                        
                        console.log('Final periods array (first 5):', periods.slice(0, 5));
                        
                        // Take only the last 24 data points
                        const last24NumericValues = numericValues.slice(-24);
                        const last24Periods = periods.slice(-24);
                        
                        console.log('Last 24 periods:', last24Periods);
                        
                        // Check for issues in the last 24 points
                        const totalRowsToCheck = Math.min(24, uploadedData.rawData.length);
                        const lastRows = uploadedData.rawData.slice(-totalRowsToCheck);
                        
                        let validPointsInLast24 = 0;
                        lastRows.forEach(row => {
                            const value = row[metric.column];
                            if (value !== '' && value !== null && value !== undefined) {
                                const numValue = parseFloat(value.toString().replace(',', '.'));
                                if (!isNaN(numValue)) {
                                    validPointsInLast24++;
                                }
                            }
                        });
                        
                        // Check if there are missing/invalid data points in the last 24
                        if (validPointsInLast24 < totalRowsToCheck || last24NumericValues.length < 8) {
                            hasError = true;
                            if (last24NumericValues.length < 8) {
                                errorMessage = getCurrentLang().errorInsufficientData;
                            } else {
                                errorMessage = getCurrentLang().errorMissingData;
                            }
                        }
                        
                        processedResults.push({
                            metric: metric,
                            results: hasError ? null : calcSPC(last24NumericValues, last24Periods),
                            institution: uploadedData.institutionName,
                            hasError: hasError,
                            errorMessage: errorMessage
                        });
                    });

                    currentChartIndex = 0;
                    showChartSection();
                    
                } catch (error) {
                    showError(getCurrentLang().errorProcessing + error.message);
                } finally {
                    showLoading(false);
                }
            }, 500);
        }

        function showChartSection() {
            document.getElementById('uploadSection').style.display = 'none';
            document.getElementById('chartSection').style.display = 'block';
            document.getElementById('headerBackBtn').style.display = 'block';
            document.getElementById('downloadButtonsContainer').style.display = 'flex';
            
            updateMetricSelector();
            updateChart();
            updateNavigation();
        }

        function updateMetricSelector() {
            const selector = document.getElementById('metricSelector');
            selector.innerHTML = '';
            
            processedResults.forEach((result, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = result.metric.name;
                if (index === currentChartIndex) {
                    option.selected = true;
                }
                selector.appendChild(option);
            });
        }

        function updateChart() {
            if (processedResults.length === 0) return;

            const currentData = processedResults[currentChartIndex];
            const metric = currentData.metric;
            const institution = currentData.institution;

            // Check if this metric has an error
            if (currentData.hasError) {
                displayErrorChart(metric.name, institution, currentData.errorMessage);
                return;
            }

            const results = currentData.results;
            const dataCount = results.length;
            const finalTitle = `${metric.name} - ${institution} (${dataCount} ${getCurrentLang().points})`;

            createSPCChart(results, metric, metric.name, finalTitle);
        }

        function displayErrorChart(metricName, institution, errorMessage) {
            const ctx = document.getElementById('spcChart').getContext('2d');
            
            // Destroy existing chart
            if (spcChart) {
                spcChart.destroy();
            }

            // Create error display chart
            spcChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `${metricName} - ${institution}`,
                            font: {
                                size: 18,
                                weight: 'bold'
                            },
                            color: '#dc3545',
                            padding: 20
                        },
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            display: false
                        }
                    },
                    animation: false
                },
                plugins: [{
                    id: 'errorMessage',
                    beforeDraw: function(chart) {
                        const ctx = chart.ctx;
                        const width = chart.width;
                        const height = chart.height;
                        
                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Error title
                        ctx.font = 'bold 32px Arial';
                        ctx.fillStyle = '#dc3545';
                        ctx.fillText('ERROR', width / 2, height / 2 - 30);
                        
                        // Error message
                        ctx.font = '16px Arial';
                        ctx.fillStyle = '#6c757d';
                        ctx.fillText(errorMessage, width / 2, height / 2 + 20);
                        
                        ctx.restore();
                    }
                }]
            });
        }

        function createSPCChart(results, metric, dataLabel, chartTitle) {
            const ctx = document.getElementById('spcChart').getContext('2d');
            const lang = getCurrentLang();

            // Prepare data
            const labels = results.map(r => r.date);
            const dpData = results.map(r => r.dp);
            const dpaData = results.map(r => r.dpa);
            const uclData = results.map(r => r.ucl);
            const lclData = results.map(r => r.lcl);

            // Point colors for signals
            const dpPointColors = results.map(r => r.signal === 1 ? '#FF0000' : '#4169E1');

            // Destroy existing chart
            if (spcChart) {
                spcChart.destroy();
            }

            // Create new chart
            spcChart = new Chart(ctx, {
                type: 'line',
                plugins: [ChartDataLabels],
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: `${dataLabel} (DP)`,
                            data: dpData,
                            borderColor: '#4169E1',
                            backgroundColor: 'rgba(65, 105, 225, 0.1)',
                            borderWidth: 2,
                            pointBackgroundColor: dpPointColors,
                            pointBorderColor: dpPointColors,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            tension: 0
                        },
                        {
                            label: lang.average,
                            data: dpaData,
                            borderColor: '#228B22',
                            backgroundColor: 'rgba(34, 139, 34, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0
                        },
                        {
                            label: lang.upperLimit,
                            data: uclData,
                            borderColor: '#DC143C',
                            backgroundColor: 'rgba(220, 20, 60, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0
                        },
                        {
                            label: lang.lowerLimit,
                            data: lclData,
                            borderColor: '#DC143C',
                            backgroundColor: 'rgba(220, 20, 60, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle,
                            font: {
                                size: 18,
                                weight: 'bold'
                            },
                            color: '#2c3e50',
                            padding: 20
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: false,
                                padding: 20,
                                boxWidth: 15,
                                boxHeight: 2,
                                font: {
                                    size: 12
                                },
                                generateLabels: function(chart) {
                                    const original = Chart.defaults.plugins.legend.labels.generateLabels;
                                    const labels = original.call(this, chart);
                                    
                                    return labels.map((label, index) => {
                                        // Keep default for DP (first dataset), customize others
                                        if (index > 0) {
                                            label.fillStyle = label.strokeStyle;
                                            label.strokeStyle = label.strokeStyle;
                                        }
                                        return label;
                                    });
                                }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            borderColor: '#3498db',
                            borderWidth: 1,
                            usePointStyle: false,
                            boxWidth: 15,
                            boxHeight: 2,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return context.dataset.label + ': ' + fmt(value);
                                },
                                afterBody: function(tooltipItems) {
                                    const index = tooltipItems[0].dataIndex;
                                    const result = results[index];
                                    let extra = [];
                                    
                                    if (result.signal === 1) {
                                        extra.push(lang.signalDetected);
                                    }
                                    if (result.rule) {
                                        extra.push('üìã ' + result.rule);
                                    }
                                    
                                    return extra;
                                },
                                labelColor: function(context) {
                                    return {
                                        borderColor: context.dataset.borderColor,
                                        backgroundColor: context.dataset.borderColor,
                                        borderWidth: 0,
                                        borderRadius: 0
                                    };
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                return context.datasetIndex === 0;
                            },
                            align: 'top',
                            offset: 8,
                            color: function(context) {
                                const result = results[context.dataIndex];
                                return result.signal === 1 ? '#FF0000' : '#4169E1';
                            },
                            font: {
                                size: 10,
                                weight: 'bold'
                            },
                            formatter: function(value) {
                                return fmt(value);
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: lang.period,
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            ticks: {
                                maxRotation: 45,
                                font: {
                                    size: 11
                                }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: lang.value,
                                font: {
                                    weight: 'bold',
                                    size: 14
                                }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        function updateNavigation() {
            const prevBtn = document.getElementById('prevChart');
            const nextBtn = document.getElementById('nextChart');
            const counter = document.getElementById('chartCounter');
            const selector = document.getElementById('metricSelector');

            const total = processedResults.length;
            const current = currentChartIndex + 1;

            counter.textContent = `${current} / ${total}`;
            
            // Enable all navigation buttons for circular navigation
            prevBtn.disabled = false;
            nextBtn.disabled = false;
            
            selector.value = currentChartIndex;
        }

        function navigateChart(direction) {
            const total = processedResults.length;
            
            if (direction === 'prev') {
                // If at first chart, go to last chart
                currentChartIndex = currentChartIndex === 0 ? total - 1 : currentChartIndex - 1;
            } else if (direction === 'next') {
                // If at last chart, go to first chart
                currentChartIndex = currentChartIndex === total - 1 ? 0 : currentChartIndex + 1;
            }
            
            updateChart();
            updateNavigation();
        }

        function selectMetricFromDropdown(selectedIndex) {
            currentChartIndex = parseInt(selectedIndex);
            updateChart();
            updateNavigation();
        }

        async function generatePDFReport() {
            const downloadBtn = document.getElementById('downloadPDF');
            const originalText = downloadBtn.textContent;
            const lang = getCurrentLang();
            
            try {
                // Disable button and show loading
                downloadBtn.disabled = true;
                downloadBtn.textContent = lang.downloadingPDF;
                
                // Hide author credit during PDF generation
                const authorCredit = document.getElementById('authorCredit');
                const originalDisplay = authorCredit.style.display;
                authorCredit.style.display = 'none';
                
                // Initialize jsPDF
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('landscape', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                
                // Create a temporary canvas container for chart rendering
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.width = '1200px';
                tempContainer.style.height = '800px';
                tempContainer.style.backgroundColor = 'white';
                tempContainer.innerHTML = `
                    <div style="padding: 40px; background: white;">
                        <canvas id="tempChart" width="1120" height="720"></canvas>
                    </div>
                `;
                document.body.appendChild(tempContainer);
                
                // Process each metric
                for (let i = 0; i < processedResults.length; i++) {
                    const currentData = processedResults[i];
                    const metric = currentData.metric;
                    const institution = currentData.institution;
                    
                    if (i > 0) {
                        pdf.addPage();
                    }
                    
                    if (currentData.hasError) {
                        // Add error message for problematic metrics
                        pdf.setFontSize(16);
                        pdf.setTextColor(220, 20, 60);
                        const errorTitle = 'ERROR';
                        const errorTitleWidth = pdf.getTextWidth(errorTitle);
                        pdf.text(errorTitle, (pageWidth - errorTitleWidth) / 2, pageHeight / 2 - 10);
                        
                        pdf.setFontSize(12);
                        pdf.setTextColor(108, 117, 125);
                        const errorMsg = currentData.errorMessage;
                        const errorMsgWidth = pdf.getTextWidth(errorMsg);
                        pdf.text(errorMsg, (pageWidth - errorMsgWidth) / 2, pageHeight / 2 + 10);
                    } else {
                        // Create chart for this metric
                        const tempCanvas = document.getElementById('tempChart');
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        // Create the chart
                        const results = currentData.results;
                        const dataCount = results.length;
                        const finalTitle = `${metric.name} - ${institution} (${dataCount} ${lang.points})`;
                        
                        const tempChart = await createTempSPCChart(tempCtx, results, metric, metric.name, finalTitle);
                        
                        // Wait for chart to render
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Convert chart to image
                        const chartImage = tempCanvas.toDataURL('image/png', 1.0);
                        
                        // Add chart image to PDF
                        const imgWidth = pageWidth - 40;
                        const imgHeight = (imgWidth * 720) / 1120;
                        const imgX = 20;
                        const imgY = 20;
                        
                        pdf.addImage(chartImage, 'PNG', imgX, imgY, imgWidth, imgHeight);
                        
                        // Destroy temp chart
                        tempChart.destroy();
                    }
                }
                
                // Clean up
                document.body.removeChild(tempContainer);
                
                // Restore author credit visibility
                authorCredit.style.display = originalDisplay;
                
                // Generate filename
                const now = new Date();
                const timestamp = now.toISOString().slice(0, 19).replace(/:/g, '-');
                const institution = processedResults[0]?.institution || 'SPC';
                const filename = `SPC_Report_${institution}_${timestamp}.pdf`;
                
                // Download PDF
                pdf.save(filename);
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                alert('Error al generar el PDF. Por favor, int√©ntelo de nuevo.');
                
                // Restore author credit visibility in case of error
                const authorCredit = document.getElementById('authorCredit');
                if (authorCredit) {
                    authorCredit.style.display = '';
                }
            } finally {
                // Restore button
                downloadBtn.disabled = false;
                downloadBtn.textContent = originalText;
            }
        }

        async function generateODPPresentation() {
            const downloadBtn = document.getElementById('downloadODP');
            const originalText = downloadBtn.textContent;
            const lang = getCurrentLang();
            
            try {
                // Disable button and show loading
                downloadBtn.disabled = true;
                downloadBtn.textContent = lang.downloadingODP;
                
                // Create a temporary canvas container for chart rendering
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.width = '1200px';
                tempContainer.style.height = '800px';
                tempContainer.style.backgroundColor = 'white';
                tempContainer.innerHTML = `
                    <div style="padding: 40px; background: white;">
                        <canvas id="tempChartODP" width="1120" height="720"></canvas>
                    </div>
                `;
                document.body.appendChild(tempContainer);
                
                // Initialize JSZip for creating ODP file
                const zip = new JSZip();
                
                // Create ODP structure
                createODPStructure(zip);
                
                // Create content.xml with slides
                let contentXml = createContentXmlHeader();
                
                // Generate chart images and slide content
                const chartImages = [];
                for (let i = 0; i < processedResults.length; i++) {
                    const currentData = processedResults[i];
                    const metric = currentData.metric;
                    const institution = currentData.institution;
                    
                    if (!currentData.hasError) {
                        // Create chart for this metric
                        const tempCanvas = document.getElementById('tempChartODP');
                        const tempCtx = tempCanvas.getContext('2d');
                        
                        // Create the chart
                        const results = currentData.results;
                        const dataCount = results.length;
                        const finalTitle = `${metric.name} - ${institution} (${dataCount} ${lang.points})`;
                        
                        const tempChart = await createTempSPCChart(tempCtx, results, metric, metric.name, finalTitle);
                        
                        // Wait for chart to render
                        await new Promise(resolve => setTimeout(resolve, 500));
                        
                        // Convert chart to base64 image
                        const chartImage = tempCanvas.toDataURL('image/png', 1.0);
                        const base64Data = chartImage.split(',')[1];
                        
                        // Add image to zip
                        const imageName = `chart${i + 1}.png`;
                        zip.file(`Pictures/${imageName}`, base64Data, {base64: true});
                        
                        // Add slide content
                        contentXml += createSlideXml(i + 1, finalTitle, imageName);
                        
                        // Destroy temp chart
                        tempChart.destroy();
                    } else {
                        // Create error slide
                        contentXml += createErrorSlideXml(i + 1, `${metric.name} - ${institution}`, currentData.errorMessage);
                    }
                }
                
                contentXml += createContentXmlFooter();
                
                // Add content.xml to zip
                zip.file('content.xml', contentXml);
                
                // Clean up
                document.body.removeChild(tempContainer);
                
                // Generate and download ODP file
                const blob = await zip.generateAsync({type: 'blob'});
                
                // Generate filename
                const now = new Date();
                const timestamp = now.toISOString().slice(0, 19).replace(/:/g, '-');
                const institution = processedResults[0]?.institution || 'SPC';
                const filename = `SPC_Presentation_${institution}_${timestamp}.odp`;
                
                // Download ODP
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
                
            } catch (error) {
                console.error('Error generating ODP:', error);
                alert('Error al generar el archivo ODP. Por favor, int√©ntelo de nuevo.');
            } finally {
                // Restore button
                downloadBtn.disabled = false;
                downloadBtn.textContent = originalText;
            }
        }

        function createODPStructure(zip) {
            // mimetype
            zip.file('mimetype', 'application/vnd.oasis.opendocument.presentation');
            
            // META-INF/manifest.xml
            const manifestXml = `<?xml version="1.0" encoding="UTF-8"?>
<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">
    <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.presentation"/>
    <manifest:file-entry manifest:full-path="content.xml" manifest:media-type="text/xml"/>
    <manifest:file-entry manifest:full-path="styles.xml" manifest:media-type="text/xml"/>
    <manifest:file-entry manifest:full-path="meta.xml" manifest:media-type="text/xml"/>
    <manifest:file-entry manifest:full-path="Pictures/" manifest:media-type=""/>
</manifest:manifest>`;
            zip.file('META-INF/manifest.xml', manifestXml);
            
            // meta.xml
            const metaXml = `<?xml version="1.0" encoding="UTF-8"?>
<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:ooo="http://openoffice.org/2004/office" office:version="1.2">
    <office:meta>
        <meta:generator>SPC Dashboard</meta:generator>
        <dc:title>SPC Analysis Report</dc:title>
        <dc:description>Statistical Process Control Charts</dc:description>
        <dc:creator>Dr. Gustavo Possel S.</dc:creator>
        <dc:date>${new Date().toISOString()}</dc:date>
    </office:meta>
</office:document-meta>`;
            zip.file('meta.xml', metaXml);
            
            // styles.xml
            const stylesXml = `<?xml version="1.0" encoding="UTF-8"?>
<office:document-styles xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:number="urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0" xmlns:presentation="urn:oasis:names:tc:opendocument:xmlns:presentation:1.0" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" xmlns:chart="urn:oasis:names:tc:opendocument:xmlns:chart:1.0" xmlns:dr3d="urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="urn:oasis:names:tc:opendocument:xmlns:form:1.0" xmlns:script="urn:oasis:names:tc:opendocument:xmlns:script:1.0" xmlns:ooo="http://openoffice.org/2004/office" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:dom="http://www.w3.org/2001/xml-events" office:version="1.2">
    <office:styles>
        <draw:gradient draw:name="Gradient_20_1" draw:display-name="Gradient 1" draw:style="linear" draw:start-color="#729fcf" draw:end-color="#3465a4" draw:start-intensity="100%" draw:end-intensity="100%" draw:angle="0" draw:border="0%"/>
        <style:style style:name="Standard" style:family="graphic">
            <style:graphic-properties draw:stroke="none" draw:fill="none" draw:textarea-horizontal-align="center" draw:textarea-vertical-align="middle" draw:color-mode="standard" draw:luminance="0%" draw:contrast="0%" draw:gamma="100%" draw:red="0%" draw:green="0%" draw:blue="0%" fo:clip="rect(0cm, 0cm, 0cm, 0cm)" draw:image-opacity="100%" style:mirror="none"/>
            <style:paragraph-properties style:text-autospace="ideograph-alpha" style:punctuation-wrap="simple" style:line-break="strict" style:writing-mode="lr-tb" style:font-independent-line-spacing="false">
                <style:tab-stops/>
            </style:paragraph-properties>
            <style:text-properties style:use-window-font-color="true" fo:font-family="&apos;Liberation Sans&apos;" style:font-family-generic="swiss" style:font-pitch="variable" fo:font-size="18pt" fo:language="en" fo:country="US" style:letter-kerning="true" style:font-family-asian="&apos;DejaVu Sans&apos;" style:font-family-generic-asian="system" style:font-pitch-asian="variable" style:font-size-asian="18pt" style:language-asian="zh" style:country-asian="CN" style:font-family-complex="&apos;DejaVu Sans&apos;" style:font-family-generic-complex="system" style:font-pitch-complex="variable" style:font-size-complex="18pt" style:language-complex="hi" style:country-complex="IN"/>
        </style:style>
    </office:styles>
    <office:automatic-styles>
        <style:page-layout style:name="PM1">
            <style:page-layout-properties fo:margin-top="2.54cm" fo:margin-bottom="2.54cm" fo:margin-left="1.91cm" fo:margin-right="1.91cm" fo:page-width="29.7cm" fo:page-height="21cm" style:print-orientation="landscape"/>
        </style:page-layout>
        <draw:marker draw:name="Arrow"/>
    </office:automatic-styles>
    <office:master-styles>
        <style:master-page style:name="Default" style:page-layout-name="PM1" draw:style-name="dp1"/>
    </office:master-styles>
</office:document-styles>`;
            zip.file('styles.xml', stylesXml);
        }

        function createContentXmlHeader() {
            return `<?xml version="1.0" encoding="UTF-8"?>
<office:document-content xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:draw="urn:oasis:names:tc:opendocument:xmlns:drawing:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:number="urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0" xmlns:presentation="urn:oasis:names:tc:opendocument:xmlns:presentation:1.0" xmlns:svg="urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0" xmlns:chart="urn:oasis:names:tc:opendocument:xmlns:chart:1.0" xmlns:dr3d="urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0" xmlns:math="http://www.w3.org/1998/Math/MathML" xmlns:form="urn:oasis:names:tc:opendocument:xmlns:form:1.0" xmlns:script="urn:oasis:names:tc:opendocument:xmlns:script:1.0" xmlns:ooo="http://openoffice.org/2004/office" xmlns:ooow="http://openoffice.org/2004/writer" xmlns:oooc="http://openoffice.org/2004/calc" xmlns:dom="http://www.w3.org/2001/xml-events" office:version="1.2">
    <office:scripts/>
    <office:font-face-decls>
        <style:font-face style:name="Liberation Sans" svg:font-family="&apos;Liberation Sans&apos;" style:font-family-generic="swiss" style:font-pitch="variable"/>
    </office:font-face-decls>
    <office:automatic-styles>
        <style:style style:name="dp1" style:family="drawing-page"/>
        <style:style style:name="gr1" style:family="graphic">
            <style:graphic-properties draw:textarea-horizontal-align="center" draw:textarea-vertical-align="middle" draw:auto-grow-height="false" draw:auto-grow-width="false"/>
        </style:style>
        <style:style style:name="P1" style:family="paragraph">
            <style:paragraph-properties fo:text-align="center"/>
            <style:text-properties fo:font-size="24pt" fo:font-weight="bold"/>
        </style:style>
    </office:automatic-styles>
    <office:body>
        <office:presentation>`;
        }

        function createSlideXml(slideNumber, title, imageName) {
            return `
            <draw:page draw:name="page${slideNumber}" draw:style-name="dp1" draw:master-page-name="Default">
                <draw:frame draw:style-name="gr1" draw:layer="layout" svg:width="26cm" svg:height="18cm" svg:x="1.85cm" svg:y="1.5cm">
                    <draw:image xlink:href="Pictures/${imageName}" xlink:type="simple" xlink:show="embed" xlink:actuate="onLoad"/>
                </draw:frame>
            </draw:page>`;
        }

        function createErrorSlideXml(slideNumber, title, errorMessage) {
            return `
            <draw:page draw:name="page${slideNumber}" draw:style-name="dp1" draw:master-page-name="Default">
                <draw:frame draw:style-name="gr1" draw:text-style-name="P1" draw:layer="layout" svg:width="25cm" svg:height="2cm" svg:x="2.35cm" svg:y="1cm">
                    <draw:text-box>
                        <text:p text:style-name="P1">${escapeXml(title)}</text:p>
                    </draw:text-box>
                </draw:frame>
                <draw:frame draw:style-name="gr1" draw:layer="layout" svg:width="20cm" svg:height="8cm" svg:x="4.85cm" svg:y="7cm">
                    <draw:text-box>
                        <text:p><text:span style:font-size="32pt" style:color="#dc3545" style:font-weight="bold">ERROR</text:span></text:p>
                        <text:p><text:span style:font-size="16pt" style:color="#6c757d">${escapeXml(errorMessage)}</text:span></text:p>
                    </draw:text-box>
                </draw:frame>
            </draw:page>`;
        }

        function createContentXmlFooter() {
            return `
        </office:presentation>
    </office:body>
</office:document-content>`;
        }

        function escapeXml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function createTempSPCChart(ctx, results, metric, dataLabel, chartTitle) {
            const lang = getCurrentLang();

            // Prepare data
            const labels = results.map(r => r.date);
            const dpData = results.map(r => r.dp);
            const dpaData = results.map(r => r.dpa);
            const uclData = results.map(r => r.ucl);
            const lclData = results.map(r => r.lcl);

            // Point colors for signals
            const dpPointColors = results.map(r => r.signal === 1 ? '#FF0000' : '#4169E1');

            // Create chart with same configuration as main chart
            return new Chart(ctx, {
                type: 'line',
                plugins: [ChartDataLabels],
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: `${dataLabel} (DP)`,
                            data: dpData,
                            borderColor: '#4169E1',
                            backgroundColor: 'rgba(65, 105, 225, 0.1)',
                            borderWidth: 3,
                            pointBackgroundColor: dpPointColors,
                            pointBorderColor: dpPointColors,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            tension: 0
                        },
                        {
                            label: lang.average,
                            data: dpaData,
                            borderColor: '#228B22',
                            backgroundColor: 'rgba(34, 139, 34, 0.1)',
                            borderWidth: 3,
                            pointRadius: 0,
                            tension: 0
                        },
                        {
                            label: lang.upperLimit,
                            data: uclData,
                            borderColor: '#DC143C',
                            backgroundColor: 'rgba(220, 20, 60, 0.1)',
                            borderWidth: 3,
                            pointRadius: 0,
                            tension: 0
                        },
                        {
                            label: lang.lowerLimit,
                            data: lclData,
                            borderColor: '#DC143C',
                            backgroundColor: 'rgba(220, 20, 60, 0.1)',
                            borderWidth: 3,
                            pointRadius: 0,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        title: {
                            display: true,
                            text: chartTitle,
                            font: {
                                size: 24,
                                weight: 'bold'
                            },
                            color: '#2c3e50',
                            padding: 30
                        },
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                usePointStyle: false,
                                padding: 25,
                                boxWidth: 20,
                                boxHeight: 3,
                                font: {
                                    size: 16
                                }
                            }
                        },
                        datalabels: {
                            display: function(context) {
                                return context.datasetIndex === 0;
                            },
                            align: 'top',
                            offset: 10,
                            color: function(context) {
                                const result = results[context.dataIndex];
                                return result.signal === 1 ? '#FF0000' : '#4169E1';
                            },
                            font: {
                                size: 12,
                                weight: 'bold'
                            },
                            formatter: function(value) {
                                return fmt(value);
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: lang.period,
                                font: {
                                    weight: 'bold',
                                    size: 18
                                }
                            },
                            ticks: {
                                maxRotation: 45,
                                font: {
                                    size: 14
                                }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: lang.value,
                                font: {
                                    weight: 'bold',
                                    size: 18
                                }
                            },
                            ticks: {
                                font: {
                                    size: 14
                                }
                            },
                            grid: {
                                display: true,
                                color: 'rgba(0,0,0,0.1)'
                            }
                        }
                    }
                }
            });
        }

        function backToMenu() {
            document.getElementById('fileInput').value = '';
            document.getElementById('chartSection').style.display = 'none';
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('headerBackBtn').style.display = 'none';
            document.getElementById('downloadButtonsContainer').style.display = 'none';
            
            if (spcChart) {
                spcChart.destroy();
                spcChart = null;
            }
            
            uploadedData = null;
            processedResults = [];
            currentChartIndex = 0;
        }

        // Event listeners
        document.getElementById('fileInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            showLoading(true);
            
            try {
                let data;
                const fileName = file.name.toLowerCase();
                
                if (fileName.endsWith('.csv')) {
                    data = await processCSVFile(file);
                } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                    data = await processExcelFile(file);
                } else {
                    throw new Error(getCurrentLang().errorFileFormat);
                }

                const analysis = analyzeDataStructure(data);
                uploadedData = analysis;
                
                if (analysis.metrics.filter(m => m.validForSPC).length > 0) {
                    processAllMetrics();
                } else {
                    showError(getCurrentLang().errorNoValidMetrics);
                    showLoading(false);
                }
                
            } catch (error) {
                showError(getCurrentLang().errorProcessing + error.message);
                console.error('Error:', error);
                showLoading(false);
            }
        });

        // Drag and drop functionality
        const uploadSection = document.getElementById('uploadSection');
        
        uploadSection.addEventListener('dragover', function(e) {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });
        
        uploadSection.addEventListener('dragleave', function(e) {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
        });
        
        uploadSection.addEventListener('drop', function(e) {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                document.getElementById('fileInput').files = files;
                document.getElementById('fileInput').dispatchEvent(new Event('change'));
            }
        });

        // Initialize language and event listeners
        document.addEventListener('DOMContentLoaded', function() {
            updateLanguage();
        });

        // Language toggle event listener
        document.getElementById('langToggle').addEventListener('click', function() {
            isEnglish = !isEnglish;
            updateLanguage();
        });

        // Header back button event listener
        document.getElementById('headerBackBtn').addEventListener('click', backToMenu);

        // PDF download button event listener
        document.getElementById('downloadPDF').addEventListener('click', generatePDFReport);

        // ODP download button event listener
        document.getElementById('downloadODP').addEventListener('click', generateODPPresentation);

        // Back to index button event listener
        document.getElementById('backToIndex').addEventListener('click', function() {
            window.location.href = 'index.html';
        });

        // Navigation event listeners
        document.getElementById('prevChart').addEventListener('click', () => navigateChart('prev'));
        document.getElementById('nextChart').addEventListener('click', () => navigateChart('next'));
        document.getElementById('metricSelector').addEventListener('change', (e) => selectMetricFromDropdown(e.target.value));

         // Initialize language and event listeners
        document.addEventListener('DOMContentLoaded', function() {
            updateLanguage();
            
            // Add keyboard navigation
            document.addEventListener('keydown', function(e) {
                // Only enable keyboard navigation when charts are visible
                const chartSection = document.getElementById('chartSection');
                if (!chartSection || chartSection.style.display === 'none' || processedResults.length === 0) {
                    return;
                }
                
                // Check if user is typing in an input field or textarea
                const activeElement = document.activeElement;
                if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
                    return;
                }
                
                // Handle arrow key navigation
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    console.log('Left arrow pressed - navigating to previous chart');
                    navigateChart('prev');
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    console.log('Right arrow pressed - navigating to next chart');
                    navigateChart('next');
                }
            });
        });
    </script>
</body>
</html>
